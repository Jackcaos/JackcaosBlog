(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{377:function(t,e,s){"use strict";s.r(e);var a=s(42),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"宝藏vite"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宝藏vite"}},[t._v("#")]),t._v(" 宝藏Vite")]),t._v(" "),s("p",[t._v("当一个B端项目大到一定程度的时候，在开发环境改动一个东西，到页面重新渲染出来感觉过了一个世纪，webpack的痛就被无情的暴露了出来，而vite就像是这种大型项目的救星。")]),t._v(" "),s("h2",{attrs:{id:"vite的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vite的优点"}},[t._v("#")]),t._v(" Vite的优点")]),t._v(" "),s("p",[t._v("我们在Vite的官网实际上就可以发现它把自己的优势写在第一条（好像大部分的框架或者工具都是先介绍自己的优势的），接下来我们看看Vite的优势。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("开发环境打包快")]),t._v("：\n众所周知webpack是根据我们entry文件，然后根据模块的依赖情况，将所有的文件打包生成一个bundle，构建出一个强大的依赖树。由于打包的过程是静态，然后每次更改都会重新打包，随着项目增大，这个过程将变得十分漫长。")])]),t._v(" "),s("p",[t._v("vite基于浏览器对ES Module的支持(即script标签可将type设置为module)，在需要加载某个模块时，Vite 只需要在浏览器请求源码时进行转换并按需提供源码即可，不需要和webpack一样提前将所有的模块打包。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("快速预构建依赖")]),t._v("\nvite是基于esbuild进行预构建的，速度会比普通的JS编写的打包器快很多。")])]),t._v(" "),s("p",[t._v("除了上面两个优势，其还"),s("code",[t._v("内置了很多编译配置")]),t._v("，且其"),s("code",[t._v("支持多种框架")]),t._v("，无框架的限制。")]),t._v(" "),s("h2",{attrs:{id:"预构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预构建"}},[t._v("#")]),t._v(" 预构建")]),t._v(" "),s("p",[t._v("在项目刚初始化，第一次启动时，命令行会出现一下信息：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Optimizable dependencies detected"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" （侦测到可优化的依赖：）\nreact"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" react"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("dom\nPre"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("bundling them to speed up dev server page load"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("（将预构建它们以提升开发服务器页面加载速度）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" will be run only when your dependencies have changed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("（这将只会在你的依赖发生变化时执行）\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("其主要考虑的是"),s("strong",[t._v("CommonJS 和 UMD 兼容性")]),t._v("和"),s("strong",[t._v("减少页面请求")]),t._v("两方面原因：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("CommonJS 和 UMD 兼容性:")]),t._v("  开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。")]),t._v(" "),s("li",[s("strong",[t._v("减少页面请求:")]),t._v(" 由于一些包将它们的 ES 模块构建作为许多单独的文件相互导入，则每引入一个模块都需要发送一个请求，大量请求会导致页面阻塞，所以vite在预构建阶段会根据ESM依赖关系将他们转为单个的模块，从而将多个请求合并为单个请求。")])]),t._v(" "),s("p",[t._v("正是由于vite对依赖的预构建，在无依赖发生变化时，"),s("code",[t._v("二次启动速度会明显加快")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"一些思考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一些思考"}},[t._v("#")]),t._v(" 一些思考")]),t._v(" "),s("p",[t._v("vite凭借"),s("strong",[t._v("基于Esbuild依赖出色的预构建能力")]),t._v("，和其"),s("strong",[t._v("以ESM的形式提供源码方式")]),t._v("，在开发环境下对大型的项目的构建速度比冷启动的webpack快不少。但是其生产环境是基于rollup进行打包，其实和我们的webpack区别不大（可能webpack更让人值得信赖）。并且生产环境更多考量的更多还是稳定性，而vite的开发环境与生产环境并不是用的同一个方式打包，不免让人有些担心。")]),t._v(" "),s("p",[t._v("所以我觉得对于一些内部的CMS平台可以尝试的接入Vite,H5的话可以观望观望，毕竟一般H5项目代码量比CMS还是会少很多，开发环境下打包速度不至于特别慢，且H5可能更在意项目的稳定。")])])}),[],!1,null,null,null);e.default=v.exports}}]);