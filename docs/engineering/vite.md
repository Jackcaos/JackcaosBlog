---
title: 前端工程化的新星——Vite
collapsable: true
---

## 宝藏Vite
当一个B端项目大到一定程度的时候，在开发环境改动一个东西，到页面重新渲染出来感觉过了一个世纪，webpack的痛就被无情的暴露了出来，而vite就像是这种大型项目的救星。

## Vite的优点
我们在Vite的官网实际上就可以发现它把自己的优势写在第一条（好像大部分的框架或者工具都是先介绍自己的优势的），接下来我们看看Vite的优势。

- `开发环境打包快`：
众所周知webpack是根据我们entry文件，然后根据模块的依赖情况，将所有的文件打包生成一个bundle，构建出一个强大的依赖树。由于打包的过程是静态，然后每次更改都会重新打包，随着项目增大，这个过程将变得十分漫长。

vite基于浏览器对ES Module的支持(即script标签可将type设置为module)，在需要加载某个模块时，Vite 只需要在浏览器请求源码时进行转换并按需提供源码即可，不需要和webpack一样提前将所有的模块打包。

- `快速预构建依赖`
vite是基于esbuild进行预构建的，速度会比普通的JS编写的打包器快很多。

除了上面两个优势，其还`内置了很多编译配置`，且其`支持多种框架`，无框架的限制。


## 预构建
在项目刚初始化，第一次启动时，命令行会出现一下信息：
```js
Optimizable dependencies detected: （侦测到可优化的依赖：）
react, react-dom
Pre-bundling them to speed up dev server page load...（将预构建它们以提升开发服务器页面加载速度）
(this will be run only when your dependencies have changed)（这将只会在你的依赖发生变化时执行）
```
其主要考虑的是**CommonJS 和 UMD 兼容性**和**减少页面请求**两方面原因：
- **CommonJS 和 UMD 兼容性:**  开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。
- **减少页面请求:** 由于一些包将它们的 ES 模块构建作为许多单独的文件相互导入，则每引入一个模块都需要发送一个请求，大量请求会导致页面阻塞，所以vite在预构建阶段会根据ESM依赖关系将他们转为单个的模块，从而将多个请求合并为单个请求。

正是由于vite对依赖的预构建，在无依赖发生变化时，`二次启动速度会明显加快`。

## 一些思考
vite凭借**基于Esbuild依赖出色的预构建能力**，和其**以ESM的形式提供源码方式**，在开发环境下对大型的项目的构建速度比冷启动的webpack快不少。但是其生产环境是基于rollup进行打包，其实和我们的webpack区别不大（可能webpack更让人值得信赖）。并且生产环境更多考量的更多还是稳定性，而vite的开发环境与生产环境并不是用的同一个方式打包，不免让人有些担心。

所以我觉得对于一些内部的CMS平台可以尝试的接入Vite,H5的话可以观望观望，毕竟一般H5项目代码量比CMS还是会少很多，开发环境下打包速度不至于特别慢，且H5可能更在意项目的稳定。
